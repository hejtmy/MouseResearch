DECLARE FUNCTION CheckLever& ()
DECLARE FUNCTION MidnightCorrection()

DECLARE SUB WaitForTime(wait_time as SINGLE)	'Runs for designated time - basically pauses the scrip

DECLARE SUB DoDRLExperiment(loop_start_time as SINGLE,cycle as TCycle)
DECLARE SUB DoBasicExperiment(loop_start_time as SINGLE, cycle as TCycle)

DECLARE SUB RewardEachLever()
DECLARE SUB RewardEachNthLever(nth%)

DECLARE SUB TryWrite(last_time as SINGLE)
DECLARE SUB FillCycles(n_cycles%,c_dur!)


OPTION BASE 1
'----------------------------------------------------------------------------
'       Define user types
'----------------------------------------------------------------------------
' $DYNAMIC
' $DYNAMIC
TYPE TExperiment
    type AS STRING * 10 'sets the type of the experiment to DRL, BASIC ...
    reward AS STRING * 10 'sets the reward scenario to NTH, EACH ...
    reward_duration AS SINGLE '
    reward_number AS INTEGER 'number to define either nth reward or time during which
    inter_trial_time AS SINGLE
END TYPE

TYPE TCycle
	duration AS SINGLE	'cycle duration in seconds
END TYPE

TYPE TLever
  n AS LONG             'number of the last response
  t AS LONG             'time of the last response
  nRew AS LONG          'number of the next rewarded response
  tRew AS LONG          'min time of the next rewarded response
  tPom AS LONG          '
  status AS LONG
  status0 AS LONG
  sensitivity AS LONG   '(10msec)
  address AS LONG		'parallel port address
  bit AS LONG			
END TYPE

TYPE TFeeder
  d AS LONG             'duration (10msec) of feeder activation
  delay AS LONG         'activation delay (10msec)
  t0 AS LONG            'time (10msec) of the last activation
  status AS LONG        '0..no activated, -1 or 1..activated
  address AS LONG
  bit AS LONG
END TYPE
'----------------------------------------------------------------------------
'       DECLARE VARIABLES
'----------------------------------------------------------------------------
time_since_start AS SINGLE
DIM lever AS TLever
DIM feeder AS TFeeder
DIM experiment AS TExperiment
DIM current_cycle as TCycle
DIM write_interval as SINGLE	'how often do we want to log stuff

DIM fstr$       'output file format string

'----------------------------------------------------------------------------
'       Open output file
'----------------------------------------------------------------------------

fid = FREEFILE
name_file:
INPUT ; "Type output file name and then press Enter: ", outfile$
IF LEN(outfile$) = 0 THEN
    PRINT "Choose a name, please"
    GOTO name_file
END IF
OPEN outfile$ FOR BINARY AS #fid
IF LOF(fid) <> 0 THEN 'if the file is NOT empty
    CLOSE #fid
    rewrite_file: 'gotopoint
    PRINT "File already exists. Overwrite? (Y..yes, N..no):"
    DO
        LET k$ = INKEY$
    LOOP UNTIL k$ <> ""
    SELECT CASE k$
        CASE "y"
            OPEN outfile$ FOR OUTPUT AS #fid
        CASE "n"
            GOTO name_file
        CASE ELSE
            PRINT ("You haven't selected any valid choice")
            GOTO rewrite_file
    END SELECT
ELSE
    CLOSE #fid
    OPEN outfile$ FOR OUTPUT AS #fid
END IF

'-----------------------------------
'       BASIC INICIALIZATIONS
'-----------------------------------

'get the experiment type
get_experiment_type:
INPUT ; "Please enter experiment type (basic, drl): ", e_type$
SELECT CASE e_type$
	CASE "drl"
		experiment.type = "DRL"
	CASE "basic"
		 experiment.type = "BASIC"
	CASE ELSE
		PRINT ("You haven't selected any valid choice")
		GOTO get_experiment_type
END SELECT

'get_experiment_cycles
INPUT "How many cycles should there be in an experiment?: ", n_cycles% 			'THIS IS NOT VALIDATED! TODO

'get_experiment_duration
INPUT "How long should the experiment cycle cycle last in seconds?: ", c_dur! 			'THIS IS NOT VALIDATED! TODO

DIM SHARED cycles(n_cycles%) AS TCycle
FillCycles(n_cycles%,c_dur!)

'get the reward type
get_reward_type:

INPUT ; "Please enter reward type (each, nth, first): ", r_type$
SELECT CASE e_type$
	CASE "first"
		experiment.reward = "FIRST"
	CASE "each"
		experiment.reward = "EACH"
	CASE "nth"
		experiment.reward = "NTH"
	CASE ELSE
		PRINT ("You haven't selected any valid choice")
		GOTO get_reward_type
END SELECT

'get the reward number (seconds for 
IF experiment.reward = "NTH" THEN
	INPUT "You selected each nth lever press would bring reward. Please enter how often should that be (2,3,5 etc.): ", r_num% 			'THIS IS NOT VALIDATED! TODO
	experiment.reward_number = r_num%
END IF

'get_reward_duration
INPUT "How long should the reward cycle last?: ", r_dur! 			'THIS IS NOT VALIDATED! TODO
experiment.reward_duration = r_dur!


'----------------------------------------------------------------------------
'       Main loop
'----------------------------------------------------------------------------


time_since_start = GetTime			'START OF THE EXPERIMENT


FOR i_cycle = 1 TO num_cycles STEP 1
	start_main_cycle:									'goto point
	current_cycle = cycles(i_cycle)						'initialises the cycle

	'---
	'In the designated loop time
	'---
	
	'could be maybe done better in different loop entirely - single one for each scenario
	
	'---
	'signal
	'---
	
	SELECT CASE experiment.type
		CASE "DRL"
			DoDRLExperiment()
		CASE "BASIC"
			DoBasicExperiment()
	END SELECT
	'---
	'After the loop time ends
	'---
	SELECT CASE experiment.reward
		CASE "EACH"
			RewardEachLever()
		CASE "NTH"
			RewardEachNthLever(experiment.reward_number)
		CASE "TIME"
	END SELECT
		
	WaitForTime(inter_trial_time)	'problem - mouse doesn't know it stopped being rewarded 
	end_main_cycle:					'goto point
NEXT i_cycle

CLOSE #fid
PRINT "EXPERIMENT FINISHED, PLEASE PRESS A KEY"

'----------------------------------------------------------------------------
'       END
'----------------------------------------------------------------------------

'----------------------------------------------------------------------------
'       EXPERIMENTAL SUBROUTINES
'----------------------------------------------------------------------------
SUB WaitForTime (t!) 'basically does nothing, just waits
    start_time! = GetTime
    WHILE start_time! + t! >= GetTime
        
    WEND
    CLOSE
END SUB

SUB DoDRLExperiment()
	SHARED lever as TLever
	SHARED current_cycle
	'---
	'checks for lever press during the cycle if the experiment is evil
	'---
	loop_start_time! = GetTime 	'SINGLE, should be enough
	WHILE loop_start_time! + current_cycle.duration >= GetTime
		lever_status% = CheckLever
		'need to log it in the script
		if lever_status% == X THEN GOTO start_main_cycle
	WEND
END SUB

SUB DoBasicExperiment()
	start_time! = GetTime
	last_time_write! = start_time!	'gets the last time a log has been made
    WHILE start_time! + t! >= GetTime
        last_time_write! = TryWrite(last_time_write!)
    WEND
END SUB

'----------------------------------------------------------------------------
'       REWARD SUBROUTINES
'----------------------------------------------------------------------------

SUB RewardEachLever()
	RewardEachNthLever(1)
END SUB

SUB RewardFirst()
	SHARED lever
	SHARED experiment
	'---
	'checks for lever press during the cycle if the experiment is evil
	'---
	loop_start_time! = GetTime
	feeder_activated% = 0
	WHILE loop_start_time! + experiment.reward_duration >= GetTime AND feeder_activated = 0	'the mouse has only specified time to press the lever
		lever_status% = CheckLever
		'need to log it in the script
		IF lever_status% == X THEN 
			ActivateFeeder
			feeder_activated = 1
		ENDIF
		
	WEND
END SUB

SUB RewardEachNthLever(nth%)
	SHARED lever
	SHARED experiment
	
	'---
	'checks for lever press during the cycle if the experiment is evil
	'---
	number_of_presses% = 0
	loop_start_time! = GetTime
	WHILE loop_start_time! + experiment.reward_duration >= GetTime
		lever_status% = CheckLever
		'need to log it in the script
		IF lever_status% = X THEN number_of_presses% = number_of_presses% + 1
		if number_of_presses% MOD nth% THEN ActivateFeeder
	WEND
END SUB

'----------------------------------------------------------------------------
'       HELPER SUBROUTINES
'----------------------------------------------------------------------------
'Fills Cycles with the same values that are provided
SUB FillCycles(n_cycles%,c_dur!)
	SHARED cycles
	FOR i = 1 TO n_cycles% STEP 1
		cycles(i).duration=c_dur!
	NEXT i
END SUB

'----------------------------------------------------------------------------
'       FUNCTIONS
'----------------------------------------------------------------------------
FUNCTION GetTime
	GetTime = TIMER(.01)
END FUNCTION

FUNCTION MidnightCorrection(time!)
	IF time! > TIMER THEN MidnightCorrection! = time! - 86400 'takes care of experimenting over midnight - needs to be done in fucntion if necessary
	ELSE MidnightCorrection! = time!
	END IF
END FUNCTION

FUNCTION TryWrite(last_time!)
	IF last_time! - GetTime > write_interval THEN 
		Write2File				'we write the log
		TryWrite = GetTime		'and resend the time to the SUBROUTINE
	END IF
END FUNCTION

FUNCTION CheckLever	'returns 1, 3 or lever.status * 2
  SHARED lever AS TLever, feeder AS TFeeder
  SHARED time_since_start
  
  IF lever.address >= 0 THEN 'only if we actually have a lever
    parallel_input = INP(lever.address) 											'INPUT from parallel port on designated address
    lever.status = INT((paralel_input MOD 2 ^ lever.bit) / 2 ^ (lever.bit - 1))	'need explanation for this
  END IF

  IF Lever.status0 <> Lever.status THEN								'if the new status is different from the old one
    'lever was released or pressed including bouncing
    lever.tPom = time_since_start
  END IF

  CheckLever = lever.status * 2

  IF lever.tPom > 0 AND time_since_start - lever.tPom >= lever.sensitivity THEN 	'if there was a lever press, and it was before the time we set for sensitivity
    IF lever.status = 1 THEN 										'lever released
      lever.n = lever.n + 1: lever.t = t: lever.tPom = -1
      CheckLever = 3
    ELSE
      lever.tPom = -1
      CheckLever = 1
    END IF
  END IF
  lever.status0 = lever.status 										'resets the status
END FUNCTION

FUNCTION CheckFeeder
  SHARED feeder AS TFeeder, Cs() AS TCycle
  SHARED time_since_start

  CheckFeeder = feeder.status * 2
  IF feeder.status <= 0 THEN
    IF time_since_start >= feeder.t0 AND time_since_start - feeder.t0 <= feeder.d THEN
      Feeder.status = 1
      IF feeder.address >= 0 THEN OUT feeder.address, 2 ^ feeder.bit - 1 ELSE SOUND 1000, 2
      CheckFeeder = 1
    END IF
  ELSEIF feeder.status = 1 AND t - feeder.t0 > feeder.d THEN
      Feeder.status = 0
      Cs(ct).k = 1
      InitLever
      IF feeder.address >= 0 THEN OUT feeder.address, 0 ELSE SOUND 500, 2
      CheckFeeder = 3
  END IF

END FUNCTION

SUB ActivateFeeder
  SHARED feeder AS TFeeder
  SHARED t

  IF feeder.status = 0 THEN
    feeder.t0 = t + feeder.delay
    feeder.status = -1
  END IF

END SUB


SUB Write2File

  SHARED lever AS TLever, feeder AS TFeeder
  SHARED t
	
	'WHAT do we want to write down?
    PRINT #fid, USING fstr$; msg; t; tc; c + 1; h + 1; ct + 1;
    PRINT #fid, USING fstr$; Cs(ct).sch(Cs(ct).k);
    FOR j = LBOUND(Rs) TO UBOUND(Rs)
      PRINT #fid, USING fstr$; Rs(j).x; Rs(j).y;
    NEXT j
    PRINT #fid,
END SUB

SUB Write2Screen
  SHARED Lever AS TLever, Feeder AS TFeeder
  SHARED Cs() AS TCycle, Rs() AS TRectangle, Nps()
  SHARED t, tc, c, ct, h, fid, msg, fstr$, key$


  LOCATE 1, 1
  PRINT "t:"; INT(t / 100); INT(Lever.tRew / 100);
  PRINT ", #p:"; Lever.n; Lever.nRew; "#pct:";
  FOR k = LBOUND(Nps) TO UBOUND(Nps) - 1: PRINT Nps(k); : NEXT k
  PRINT ", #rew:"; Nps(UBOUND(Nps));
  'PRINT ", tc:"; FIX(tc / 100);
  PRINT ", c:"; c + 1; ", h:"; h + 1; "msg:"; USING "######"; msg


END SUB